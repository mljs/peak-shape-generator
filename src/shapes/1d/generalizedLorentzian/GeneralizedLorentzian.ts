import { ROOT_THREE } from '../../../util/constants';
import type { GetData1DOptions } from '../GetData1DOptions';
import type { Parameter, Shape1DClass } from '../Shape1DClass';

export interface GeneralizedLorentzianClassOptions {
  /**
   * Full width at half maximum.
   * @default 500
   */
  fwhm?: number;
  /**
   * kurtosis parameter of the shape, between -1 to 2
   * @default 1
   */
  gamma?: number;
}

interface GetGeneralizedLorentzianAreaOptions {
  /**
   * The maximum intensity value of the shape
   * @default 1
   */
  height?: number;
  /**
   * Full width at half maximum.
   * @default 500
   */
  fwhm?: number;
  gamma?: number;
  x?: number;
}

/**
 * This shape is a linear combination of rational function (n|n+2), for n = 0 (lorentzian function) and n = 2
 * the parameter that combines those two functions is `gamma` and it is called the kurtosis parameter, it is an
 * implementation of generalized lorentzian shape published by Stanislav Sykora in the SMASH 2010. DOI:10.3247/SL3nmr10.006
 * @link http://www.ebyte.it/stan/Talk_ML_UserMeeting_SMASH_2010_GeneralizedLorentzian.html
 */
export class GeneralizedLorentzian implements Shape1DClass {
  /**
   * Full width at half maximum.
   * @default 500
   */
  public fwhm: number;
  /**
   * kurtosis parameter of the shape, between -1 to 2
   * @default 1
   */
  public gamma: number;

  public constructor(options: GeneralizedLorentzianClassOptions = {}) {
    const { fwhm = 500, gamma = 0.5 } = options;

    this.fwhm = fwhm;
    this.gamma = gamma;
  }

  public fwhmToWidth(fwhm = this.fwhm) {
    return generalizedLorentzianFwhmToWidth(fwhm);
  }

  public widthToFWHM(width: number) {
    return generalizedLorentzianWidthToFWHM(width);
  }

  public fct(x: number) {
    return generalizedLorentzianFct(x, this.fwhm, this.gamma);
  }

  public getArea(height = 1) {
    return getGeneralizedLorentzianArea({
      fwhm: this.fwhm,
      height,
      gamma: this.gamma,
    });
  }

  public getFactor(area?: number) {
    return getGeneralizedLorentzianFactor(area);
  }

  public getData(options: GetData1DOptions = {}) {
    return getGeneralizedLorentzianData(this, options);
  }

  public calculateHeight(area = 1) {
    const { gamma, fwhm } = this;
    return calculateGeneralizedLorentzianHeight({ fwhm, area, gamma });
  }

  public getParameters(): Parameter[] {
    return ['fwhm', 'gamma'];
  }
}

export const calculateGeneralizedLorentzianHeight = ({
  fwhm = 1,
  gamma = 1,
  area = 1,
}) => {
  return (area / fwhm / (3.14159 - 0.420894 * gamma)) * 2;
};

/**
 * expression of integral generated by Mathematica of the function
 */
export const getGeneralizedLorentzianArea = (
  options: GetGeneralizedLorentzianAreaOptions,
) => {
  const { fwhm = 500, height = 1, gamma = 1 } = options;
  return (height * fwhm * (3.14159 - 0.420894 * gamma)) / 2;
};

export const generalizedLorentzianFct = (
  x: number,
  fwhm: number,
  gamma: number,
) => {
  const u = ((2 * x) / fwhm) ** 2;
  return (1 - gamma) / (1 + u) + (gamma * (1 + u / 2)) / (1 + u + u ** 2);
};

export const generalizedLorentzianWidthToFWHM = (width: number) => {
  return width * ROOT_THREE;
};

export const generalizedLorentzianFwhmToWidth = (fwhm: number) => {
  return fwhm / ROOT_THREE;
};

export const getGeneralizedLorentzianFactor = (area = 0.9999) => {
  if (area >= 1) {
    throw new Error('area should be (0 - 1)');
  }
  const halfResidual = (1 - area) * 0.5;
  const quantileFunction = (p: number) => Math.tan(Math.PI * (p - 0.5));
  return (
    (quantileFunction(1 - halfResidual) - quantileFunction(halfResidual)) / 2
  );
};

export type GetGeneralizedLorentzianData = GetData1DOptions & {
  gamma?: number;
};

export const getGeneralizedLorentzianData = (
  shape: GeneralizedLorentzianClassOptions = {},
  options: GetGeneralizedLorentzianData = {},
) => {
  let { fwhm = 500, gamma = 1 } = shape;
  let {
    length,
    factor = getGeneralizedLorentzianFactor(),
    height = calculateGeneralizedLorentzianHeight({ fwhm, area: 1, gamma }),
  } = options;

  if (!length) {
    length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
    if (length % 2 === 0) length++;
  }

  const center = (length - 1) / 2;
  const data = new Float64Array(length);
  for (let i = 0; i <= center; i++) {
    data[i] = generalizedLorentzianFct(i - center, fwhm, gamma) * height;
    data[length - 1 - i] = data[i];
  }

  return data;
};
